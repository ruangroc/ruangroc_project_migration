---
title: "Radiation Model"
output: html_document
---
```{r setup, message = FALSE, warning = FALSE, include = TRUE}
library(tidyverse)
library(here)
library(Rmpfr)
#devtools::load_all()
```

## Background research
As seen in the image below and as explained in Caleb Robinson and Bistra Dilkina's paper, ["A Machine Learning Approach to Modeling Human Migration"](https://doi.org/10.1145/3209811.3209868), the traditional migration models can be written as the product of two parts: $T_{ij} = G_i * P_{ij}$. 

  * $T_{ij}$ is the number of people moving from every zone i to every other zone j
  * $G_i = \alpha * m_i$ is the production function that estimates number of people leaving zone i
    * $m_i$ is the population of zone i and $\alpha$ is a parameter tuned using historical data
  * $P_{ij}$ is the probability of a move occurring from i to j
    * Robinson and Dilkina note that the probability of moving from i to all other destinations j should sum to 1

```{r pressure, echo=FALSE, out.width = '75%'}
knitr::include_graphics(here("documentation", "project_notes", "Robinson_and_Dilkina_Table_1.PNG"))
```

To implement the radiation model, we'll need to create a matrix, $S_{ij}$ that will provide us with intervening opportunities between zones i and j that migrants would likely consider while moving to zone j.

## Create S_ij

$s_{ij}$ is defined as the population of all zones between i and j (excluding zones i and j) within a circle centered at i with radius d_ij. This means we'll need to use our matrices for distances between zones and population estimates for every zone.
```{r}
get_intervening_opps <- function(locations, year_data, fips, filename) {
  
  # pair distances and population estimates together in a tibble
  all_data <- locations %>% mutate(
    pop = rep(year_data, times = 51)
  )
  all_data <- all_data %>% select(origin, dest, distance, pop)
  all_data <- arrange(all_data, origin, distance)
  
  # calculate cumulative sums of populations in intervening zones for each i (origin state)
  results <- map(fips, ~ c(0, cumsum(subset(all_data, origin == . & dest != 1)$pop)))
  all_data <- all_data %>% mutate(
    sums = unlist(results, recursive = FALSE)
  )
  
  # rearrange the tibble to be in matrix order again, then store sum results as S_ij
  all_data <- arrange(all_data, origin, dest)
  S_ij <- matrix(as.vector(all_data$sums), nrow = 51, ncol = 51)
  colnames(S_ij) <- fips
  rownames(S_ij) <- fips
  
  write.csv(S_ij, filename, row.names = FALSE)
}
```

Let's generate intervening opportunities for all the datasets we have.
```{r}
pop_estimates <- read.csv(here("results", "data_cleaning_results", "population_estimates.csv"))
locations <- read.csv(here("results", "distances_between_states.csv"))
columns <- colnames(pop_estimates)

generate_int_opp_files <- function(col_name, data, locations) {
  if (col_name != "fips") {
    filename <- here("results", "radiation_model_results", paste("intervening_opportunities_", col_name, ".csv", sep=''))
    get_intervening_opps(locations, unlist(subset(data, select = col_name)), unlist(data %>% select("fips")), filename)
  }
}

result <- map(columns, ~ generate_int_opp_files(., pop_estimates, locations))
```


## Create function for calculating T_ij
```{r}
radiation_model <- function(pop_data, intervening_data, names, alpha) {
  
  # load population estimates for each state for the given year
  m_i <- matrix(rep(pop_data, times = 51), nrow = 51, ncol = 51)
  colnames(m_i) <- names
  m_j <- matrix(rep(pop_data, times = 51), nrow = 51, ncol = 51, byrow = TRUE)
  rownames(m_j) <- names
  
  S_ij <- as.matrix(read.csv(intervening_data), nrow = 51, ncol = 51)
  
  G_i <- alpha * m_i
  
  # Calculate P_ij in parts (have to handle computation with very large numbers)
  num <- matrix(as.double(mpfr(m_i, precBits = 4) * mpfr(m_j, precBits = 4)), nrow = 51, ncol = 51)

  denom1 <- as.matrix(m_i + S_ij)
  denom2 <- as.matrix(m_i + m_j + S_ij)
  denom <- matrix((mpfr(denom1, precBits = 4) * mpfr(denom2, precBits = 4)), nrow = 51, ncol = 51)
  d <- matrix(as.double(denom), nrow = 51, ncol = 51)
  
  P_ij <- num / d
  normalize <- matrix(rep(rowSums(P_ij), times = 51), nrow = 51, ncol = 51)
  P_ij <- P_ij / normalize
  
  # Then calculate the migration matrix T_ij
  T_ij <- round(G_i * P_ij, 4)
  return(T_ij)
}
```


Now let's get radiation model estimates for every year of data we have on hand.
```{r}
pop_estimates <- read.csv(here("results", "data_cleaning_results", "population_estimates.csv"))
columns <- colnames(pop_estimates)
alpha <- 0.3

generate_radiation_matrices <- function(col_name, data, alpha) {
  if (col_name != "fips") {
    S_ij_file <- here("results", "radiation_model_results", paste("intervening_opportunities_", col_name, ".csv", sep=''))
    T_ij <- radiation_model(unlist(subset(data, select = col_name)), S_ij_file, unlist(subset(data, select = "fips")), alpha)
    radiation_filename <- here("results", "radiation_model_results", paste("alpha_", as.character(alpha), "_", col_name, ".csv", sep=''))
    write.csv(T_ij, radiation_filename, row.names = FALSE)
  }
}

result <- map(columns, ~ generate_radiation_matrices(., pop_estimates, alpha))
```

