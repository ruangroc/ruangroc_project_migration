---
title: "Simulate Future Migration"
output: html_document
---

```{r setup, message = FALSE, warning = FALSE, include = TRUE}
library(tidyverse)
library(here)
library(Rmpfr)
#devtools::load_all()
```


## Find the best alpha value for gravity model simulations 

**Gravity model**
Will probably want to store this function in a file in the R directory later

```{r}
gravity_model <- function(data, names, alpha) {
  
  # load population estimates for each state for the given year
  m_i <- matrix(rep(data, times = 51), nrow = 51, ncol = 51)
  colnames(m_i) <- names
  m_j <- matrix(rep(data, times = 51), nrow = 51, ncol = 51, byrow = TRUE)
  rownames(m_j) <- names
  
  # load distance matrix
  locations <- read.csv(here("results", "distances_between_states.csv"))
  # it was filling with negative values for some reason, hence the negative locations$distance
  distances <-- matrix(-locations$distance, nrow = 51, ncol = 51, byrow = TRUE)
  colnames(distances) <- names
  rownames(distances) <- names
  
  d_alpha <- distances^(-alpha)
  d_alpha[!is.finite(d_alpha)] <- 0
  
  G_i <- alpha * m_i
  
  part1 <- d_alpha * m_j
  numerator <- m_i * part1
  numerator[!is.finite(numerator)] <- 0
  
  denom <- matrix(rep(rowSums(part1), times = 51), nrow = 51, ncol = 51)
  
  P_ij <- numerator / denom
  
  normalize <- matrix(rep(rowSums(P_ij), times = 51), nrow = 51, ncol = 51)
  P_ij <- P_ij / normalize

  T_ij <- G_i * P_ij
  T_ij[T_ij < 0] <- 0
  
  return(T_ij)
}
```


**Optimize alpha**: Find the lowest alpha value that will minimize the least squares residual of the gravity model values.
```{r}
run_gravity_model <- function(alpha, year_data, hist_data_file) {
  fips <- c(1, 2, 4, 5, 6, 8:13, 15:42, 44:51, 53:56)
  
  T_ij <- gravity_model(year_data, fips, alpha)
  
  compare = compare <- tibble(
    origin = rep(fips, each = 51),
    dest = rep(fips, times = 51),
    gravity = as.vector(t(T_ij)),
  )
  
  historical <- read.csv(hist_data_file)
  historical <- rename(historical, origin = origin_fips, dest = dest_fips)

  compare <- left_join(compare, subset(historical, select = c(num_migrants, origin, dest)), by = c("origin", "dest"))
  compare <- subset(compare, origin != dest)
  compare <- subset(compare, is.finite(num_migrants))
  
  compare <- compare %>% mutate(
    gravity_residuals = num_migrants - gravity
  )
  
  sum_sq_res <- sum(compare$gravity_residuals^2)
  return(as.double(sum_sq_res))
}

pop_estimates <- read.csv(here("results", "data_cleaning_results", "population_estimates.csv"))


# optimize returns: minimum = alpha, objective = residual value

# minimum alpha = 0.0154
filename <- here("results", "data_cleaning_results", "clean", "US_1516.csv")
optimize(f = run_gravity_model, interval = c(0, 1), year_data = pop_estimates$year_2015, hist_data_file = filename)

# minimum alpha = 0.0204
filename <- here("results", "data_cleaning_results", "clean", "US_1617.csv")
optimize(f = run_gravity_model, interval = c(0, 1), year_data = pop_estimates$year_2016, hist_data_file = filename)

# minimum alpha = 0.0157
filename <- here("results", "data_cleaning_results", "clean", "US_1718.csv")
optimize(f = run_gravity_model, interval = c(0, 1), year_data = pop_estimates$year_2017, hist_data_file = filename)

gravity_alpha <- mean(c(0.0154, 0.0204, 0.0157))
# we'll use alpha = 0.0172 for predicting future migration using gravity model
```

## Find best alpha value for radiation model simulations

**Gravity model**
Will probably want to store this function in a file in the R directory later

```{r}
radiation_model <- function(pop_data, intervening_data, names, alpha) {
  
  # load population estimates for each state for the given year
  m_i <- matrix(rep(pop_data, times = 51), nrow = 51, ncol = 51)
  colnames(m_i) <- names
  m_j <- matrix(rep(pop_data, times = 51), nrow = 51, ncol = 51, byrow = TRUE)
  rownames(m_j) <- names
  
  S_ij <- as.matrix(read.csv(intervening_data), nrow = 51, ncol = 51)
  
  G_i <- alpha * m_i
  
  # Calculate P_ij in parts (have to handle computation with very large numbers)
  num <- matrix(as.double(mpfr(m_i, precBits = 4) * mpfr(m_j, precBits = 4)), nrow = 51, ncol = 51)

  denom1 <- as.matrix(m_i + S_ij)
  denom2 <- as.matrix(m_i + m_j + S_ij)
  denom <- matrix((mpfr(denom1, precBits = 4) * mpfr(denom2, precBits = 4)), nrow = 51, ncol = 51)
  d <- matrix(as.double(denom), nrow = 51, ncol = 51)
  
  P_ij <- num / d
  normalize <- matrix(rep(rowSums(P_ij), times = 51), nrow = 51, ncol = 51)
  P_ij <- P_ij / normalize
  
  # Then calculate the migration matrix T_ij
  T_ij <- round(G_i * P_ij, 4)
  return(T_ij)
}
```

**Optimize alpha**: Find the lowest alpha value that will minimize the least squares residual of the radiation model values.
```{r}
run_radiation_model <- function(alpha, year_data, S_ij_file, hist_data_file) {
  fips <- c(1, 2, 4, 5, 6, 8:13, 15:42, 44:51, 53:56)
  
  T_ij <- radiation_model(year_data, S_ij_file, fips, alpha)
  
  compare = compare <- tibble(
    origin = rep(fips, each = 51),
    dest = rep(fips, times = 51),
    radiation = as.vector(t(T_ij)),
  )
  
  historical <- read.csv(hist_data_file)
  historical <- rename(historical, origin = origin_fips, dest = dest_fips)

  compare <- left_join(compare, subset(historical, select = c(num_migrants, origin, dest)), by = c("origin", "dest"))
  compare <- subset(compare, origin != dest)
  compare <- subset(compare, is.finite(num_migrants))
  
  compare <- compare %>% mutate(
    radiation_residuals = num_migrants - radiation
  )
  
  sum_sq_res <- sum(compare$radiation_residuals^2)
  return(as.double(sum_sq_res))
}

pop_estimates <- read.csv(here("results", "data_cleaning_results", "population_estimates.csv"))

# min alpha = 0.0199
S_ij_file <- here("results", "radiation_model_results", "intervening_opportunities_year_2015.csv")
hist_file <- here("results", "data_cleaning_results", "clean", "US_1516.csv")
optimize(f = run_radiation_model, interval = c(0, 1), year_data = pop_estimates$year_2015, S_ij_file = S_ij_file, hist_data_file = filename)

# min alpha = 0.0198
S_ij_file <- here("results", "radiation_model_results", "intervening_opportunities_year_2016.csv")
hist_file <- here("results", "data_cleaning_results", "clean", "US_1617.csv")
optimize(f = run_radiation_model, interval = c(0, 1), year_data = pop_estimates$year_2016, S_ij_file = S_ij_file, hist_data_file = filename)

# min alpha = 0.0194
S_ij_file <- here("results", "radiation_model_results", "intervening_opportunities_year_2017.csv")
hist_file <- here("results", "data_cleaning_results", "clean", "US_1718.csv")
optimize(f = run_radiation_model, interval = c(0, 1), year_data = pop_estimates$year_2017, S_ij_file = S_ij_file, hist_data_file = filename)

radiation_alpha <- mean(c(0.0199, 0.0198, 0.0194))
# we'll use alpha = 0.0197 for predicting future migration using radiation model
```


## Predict migration flows for next 3 years

Now that we've found the most optimal alpha values to use for predicting future migration, let's put them to use.

The most recent data we have is for the 2017-18 tax year. We'll use the population estimates from that year as a starting point and calculate estimated population from that point onwards.

**Simulate migrations using gravity model**
```{r}
get_gravity_prediction <- function(pop_data, year, gravity_alpha) {
  fips <- c(1, 2, 4, 5, 6, 8:13, 15:42, 44:51, 53:56)
  
  mig_matrix <- gravity_model(pop_data, fips, gravity_alpha)
  diag(mig_matrix) <- 0
  
  filename <- here("results", "simulation_results", paste("gravity_", as.character(year), ".csv", sep = ''))
  write.csv(mig_matrix, filename, row.names = FALSE)
  
  # sum up the values in each destination column and add to population estimates to serve as next year's baseline
  column_sums <- colSums(mig_matrix)
  new_pop_data <- pop_data + column_sums
  return(new_pop_data)
}

pop_estimates <- read.csv(here("results", "data_cleaning_results", "population_estimates.csv"))
pop_data_2017 <- pop_estimates$year_2017

# get a migration matrix for the year 2018, use it in 2019's prediction, and so on
pop_data_2018 <- get_gravity_prediction(pop_data_2017, 2018, gravity_alpha)
pop_data_2019 <- get_gravity_prediction(pop_data_2018, 2019, gravity_alpha)
pop_data_2020 <- get_gravity_prediction(pop_data_2019, 2020, gravity_alpha)
pop_data_2021 <- get_gravity_prediction(pop_data_2020, 2021, gravity_alpha)
pop_data_2022 <- get_gravity_prediction(pop_data_2021, 2022, gravity_alpha)

# then visualize the results (population changes predicted by gravity model)
```

**Simulate migrations using radiation model**
Will need to generate new intervening opportunities matrices as we go along.
```{r}
get_intervening_opps <- function(locations, year_data, fips, filename) {
  
  # pair distances and population estimates together in a tibble
  all_data <- locations %>% mutate(
    pop = rep(year_data, times = 51)
  )
  all_data <- all_data %>% select(origin, dest, distance, pop)
  all_data <- arrange(all_data, origin, distance)
  
  # calculate cumulative sums of populations in intervening zones for each i (origin state)
  results <- map(fips, ~ c(0, cumsum(subset(all_data, origin == . & dest != 1)$pop)))
  all_data <- all_data %>% mutate(
    sums = unlist(results, recursive = FALSE)
  )
  
  # rearrange the tibble to be in matrix order again, then store sum results as S_ij
  all_data <- arrange(all_data, origin, dest)
  S_ij <- matrix(as.vector(all_data$sums), nrow = 51, ncol = 51)
  colnames(S_ij) <- fips
  rownames(S_ij) <- fips
  
  write.csv(S_ij, filename, row.names = FALSE)
}
```

```{r}
get_radiation_prediction <- function(pop_data, s_ij_file, new_s_ij_file, year, radiation_alpha) {
  locations <- read.csv(here("results", "distances_between_states.csv"))
  fips <- c(1, 2, 4, 5, 6, 8:13, 15:42, 44:51, 53:56)

  mig_matrix <- radiation_model(pop_data, S_ij_file, fips, radiation_alpha)
  diag(mig_matrix) <- 0
  
  filename <- here("results", "simulation_results", paste("radiation_", as.character(year), ".csv", sep = ''))
  write.csv(mig_matrix, filename, row.names = FALSE)
  
  column_sums <- colSums(mig_matrix)
  new_pop_data <- pop_data + column_sums
  
  get_intervening_opps(locations, new_pop_data, fips, new_s_ij_file)
  return(new_pop_data)
}


pop_estimates <- read.csv(here("results", "data_cleaning_results", "population_estimates.csv"))
pop_data_2017 <- pop_estimates$year_2017

s_ij_file <- here("results", "radiation_model_results", "intervening_opportunities_year_2017.csv")
new_s_ij_file <- here("results", "simulation_results", "intervening_opportunities_2018.csv")
pop_data_2018 <- get_radiation_prediction(pop_data_2017, s_ij_file, new_s_ij_file, 2018, radiation_alpha)

s_ij_file <- here("results", "simulation_results", "intervening_opportunities_2018.csv")
new_s_ij_file <- here("results", "simulation_results", "intervening_opportunities_2019.csv")
pop_data_2019 <- get_radiation_prediction(pop_data_2018, s_ij_file, new_s_ij_file, 2019, radiation_alpha)

s_ij_file <- here("results", "simulation_results", "intervening_opportunities_2019.csv")
new_s_ij_file <- here("results", "simulation_results", "intervening_opportunities_2020.csv")
pop_data_2020 <- get_radiation_prediction(pop_data_2019, s_ij_file, new_s_ij_file, 2020, radiation_alpha)

s_ij_file <- here("results", "simulation_results", "intervening_opportunities_2020.csv")
new_s_ij_file <- here("results", "simulation_results", "intervening_opportunities_2021.csv")
pop_data_2021 <- get_radiation_prediction(pop_data_2020, s_ij_file, new_s_ij_file, 2021, radiation_alpha)

s_ij_file <- here("results", "simulation_results", "intervening_opportunities_2021.csv")
new_s_ij_file <- here("results", "simulation_results", "intervening_opportunities_2022.csv")
pop_data_2022 <- get_radiation_prediction(pop_data_2021, s_ij_file, new_s_ij_file, 2022, radiation_alpha)
```



